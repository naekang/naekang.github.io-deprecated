---
layout: post
title: Chapter1 JPA 소개
category: [computer-science, jpa]
tags: [computer-science, jpa]
image: /assets/img/blog/jpa-main.png
accent_image: 
  background: url('/assets/img/blog/jj-ying.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  자바 ORM 표준 JPA 프로그래밍
invert_sidebar: true
---

# 자바 ORM 표준 JPA 프로그래밍

- ORM(Object-Relational Mapping)을 사용한 기술인 JPA를 통해 객체 중심 개발이 가능해지고 생산성과 유지보수가 좋아졌으며 테스트 작성 역시 편해졌다.

* toc
{:toc}

## SQL을 직접 다룰 때 발생하는 문제점
- 자바로 작성한 애플리케이션은 JDBC API를 사용하여 SQL을 데이터에 전달
    ![jdbc-api](/assets/img/blog/jpa-basic-1-1.jpeg){:.border.lead width="480" height="480" loading="lazy"}

### 반복, 반복 그리고 반복
- SQL의 문제점을 파악하기 위해 CRUD 기능 개발 예시
- 회원(Memeber) 객체 생성
    ~~~java
    public class Member {

        private String memberId;

        private String name;

    }
    ~~~
- 회원 객체를 데이터베이스에 관리할 목적으로 DAO(Data Access Object) 생성
    ~~~java
    public class MemberDAO {

        public Member find(String memberId) { ... }

    }
    ~~~
    - 회원 조회 기능 만들기
        1. 회원 조회용 SQL 생성
            - `SELECT MEMBER_ID, NAME FROM MEMBER M WHERE MEMBER_ID = ?`
        2. JDBC API를 사용하여 SQL 실행
            - `ResultSet rs = stmt.executeQuery(sql);`
        3. 조회 결과를 Member 객체로 매핑
            ```java
            String memberId = rs.getString("MEMBER_ID");
            String name = rs.getString("NAME");

            Member member = new Member();
            member.setMemberId(memberId);
            member.setName(name);
            ```

- 회원 등록 기능을 위해 DAO에 save 메서드 추가
    ~~~java
    public class MemberDAO {

        public Member find(String memberId) { ... }
        public void save(Member member) { ... }
    }
    ~~~
    - 회원 등록 기능 만들기
        1. 회원 등록용 SQL 생성
            - `String sql = "INSERT INTO MEMBER(MEMBER_ID, NAME) VALUES(?, ?)";`
        2. 회원 객체 값을 꺼내 SQL에 전달
            ```java
            pstmt.setString(1, member.getMemberId());
            pstmt.setString(2, member.getName());
            ```
        3. JDBC API를 사용해 SQL 실행
            - `pstmt.executeUpdate(sql);`

- 회원 수정, 삭제하는 기능 역시 위의 과정들과 비슷하며 SQL과 JDBC API를 계속해서 반복 작성해야함

### SQL에 의존적인 개발
- 위의 과정을 수행하던 중 회원의 연락처도 받고 싶다는 요청이 들어옴
- DAO, SQL문 모두 수정해야 하며 CRUD 기능 구현했던 부분들을 다 돌며 같은 수정을 반복해야함
- 또한, 데이터 접근 계층인 DAO를 사용하여 SQL을 숨긴다해도 DAO를 열어 어떤 SQL이 실행되는지 일일히 확인해야함

> 진정한 의미의 계층 분할이 어려움
> 
> 엔티티를 신뢰할 수 없음
> 
> SQL에 의존적인 개발이 불가피

### JPA와 문제 해결
- JPA가 제공하는 CRUD API 기능
  - 저장 기능
    ```java
    jpa.persist(member);
    ```
    - 객체를 데이터베이스에 저장
  - 조회 기능
    ```java
    String memberId = "helloId";
    Member member = jpa.find(Member.class, memberId);
    ```
    - 객체 하나를 데이터베이스에서 조회
  - 수정 기능
    ```java
    Member member = jpa.find(Member.class, memberId);
    member.setName("이름변경");
    ```
    - 별도의 수정 메소드는 제공하지 않음
    - 조회해서 값을 변경하면 트랜잭션 커밋시 적절한 UPDATE SQL 전달
  - 연관된 객체 조회
    ```java
    Member member = jpa.find(Member.class, memberId);
    Team team = member.getTeam();
    ```

## 패러다임의 불일치
- 객체와 관계형 데이터베이스는 지향하는 목적이 다르므로 기능과 표현 방법도 다름 = 패러다임의 불일치 문제

### 상속
- 객체는 상속이라는 기능이 있으나 테이블은 없음
- JDBC API를 사용하기 위해서는 부모 객체에서 부모 데이터만 꺼내 하나의 테이블당 한개씩 INSERT SQL을 작성해야함
- JPA를 통한 해결책
  - Item을 상속한 Album 객체 저장하기 -> `persist()` 메소드 사용
    ```java
    jpa.persist(album);
    ```
  - 객체를 ITEM, ALBUM 두 테이블에 나누어 저장
    ```sql
    INSERT INTO ITEM ...
    INSERT INTO ALBUM ...
    ```
  - Album 객체 조회
    ```java
    String albumId = "id100";
    Album album = jpa.find(Album.class, albumId);
    ```
  - JPA는 ITEM과 ALBUM 두 테이블을 조인해서 필요한 데이터를 조회하고 결과를 반환
    ```sql
    SELECT I.*, A.*
    FROM ITEM I
    JOIN ALBUM A
    ON I.ITEM_ID = A.ITEM_ID
    ```

### 연관관계
- 객체: 참조를 통해 다른 객체와의 연관관계를 가지고 참조에 접근해서 연관된 객체 조회 / 참조가 있는 방향으로만 조회 가능
- 테이블: 외래 키를 사용하여 조인하여 연관된 테이블 조회 / 외래 키 하나로 서로 접근 가능
![객체와테이블](/assets/img/blog/jpa-basic-1-2.jpeg){:.border.lead width="480" height="480" loading="lazy"}

- 객체를 테이블에 맞추어 모델링
    ~~~java
    class Member {
        
        String id; // MEMBER_ID 컬럼 사용
        Long teamId; // TEAM_ID FK 컬럼 사용
        String username; // USERNAME 컬럼 사용
    }

    class Team {

        Long id; // TEAM_ID PK 사용
        String name; // NAME 컬럼 사용
    }
    ~~~
    - 외래 키까지 RDBMS 방식에 맞추면 참조를 통해 조회할 수 없어 객체지향의 특성을 잃게됨

- 객체지향 모델링
    ~~~java
    class Member {

        String id; // MEMBER_ID 컬럼 사용
        Team team; // 참조로 연관관계를 맺음
        String username; // USERNAME 컬럼 사용

        Team getTeam() {
            return team;
        }
    }

    class Team {

        Long id; // TEAM_ID PK사용
        String name; // NAME 컬럼 사용
    }
    ~~~
    - 객체지향 모델링의 경우 객체를 테이블에 저장하거나 조회하기가 쉽지 않음
    - 개발자가 중간에서 변환 역할을 해야함
    - 저장
        - 객체를 데이터베이스 저장하려면 team필드를 TEAM_ID 외래 키 값으로 변환해야함
        ```java
        member.getId();
        member.getTeam().getId();
        member.getUsername();
        ```
    - 조회
        - TEAM_ID 외래 키 값을 Member 객체의 team 참조로 변환하여 객체에 보관
        ```sql
        SELECT M.*, T.*
            FROM MEMBER M
            JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
        ```

### 객체 그래프 탐색
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐
- JPA와 객체 그래프 탐색
  - JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 실행
  - 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룸 = **지연 로딩**
  - JPA는 지연 로딩을 투명하게 처리
  - JPA는 연관된 객체를 즉시 함께 조회할지 아니면 실제 사용되는 시점에 지연해서 조회할지 간단한 설정을 통해 정의 가능

### 비교
- 데이터베이스는 기본 키의 값으로 각 row 구분
- 객체는 두 가지 비교 방법 존재
  - 동일성(Identity) 비교는 == 비교 -> 객체 인스턴스의 주소 값 비교
  - 동등성(Equality) 비교는 `equals()`를 사용하여 객체 내부 값 비교
~~~java
class MemberDAO {
    public Member getMember(String memberId) {
        String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
        ...
        // JDBC API , SQL 실행
        return new Member { ... };
    }
}
~~~
```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);

member1 == member2; // 다름, 호출할 때마다 새로운 인스턴스가 생성됨
```

- JPA와 비교
  - JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장
    ~~~java
    String memberId = "100";
    Member member1 = jpa.find(Member.class, memberId);
    Member member2 = jpa.find(Member.class, memberId);

    member1 == member2; // 같음
    ~~~

### 정리
> 정교한 객체 모델링을 할수록 패러다임 불일치 문제가 더 커지며 이를 해결하기 위해 JPA가 등장

## JPA란 무엇인가?
- JPA(Java Persistence API)는 자바 진영의 ORM 표준 기술
  ![jpa-api](/assets/img/blog/jpa-basic-1-3.jpeg){:.border.lead width="480" height="480" loading="lazy"}
- ORM(Object-Relational Mapping): 객체와 관계형 데이터베이스 매핑
  - 다양한 패러다임의 불일치 문제 해결 가능
  - 매핑 방법만 ORM 프레임워크에 알려주면 됨
  - 객체지향 애플리케이션 개발에 집중할 수 있음
  ![jpa-api](/assets/img/blog/jpa-basic-1-4.jpeg){:.border.lead width="480" height="480" loading="lazy"}

### JPA 소개
![jpa-api](/assets/img/blog/jpa-basic-1-5.jpeg){:.border.lead width="480" height="480" loading="lazy"}
- JPA를 사용하기 위해서는 JPA를 구현한 ORM 프레임워크를 선택해야함
- JPA 버전별 특징
  - `JPA 1.0(JSR 220) 2006년`: 초기 버전, 복합 키와 연관관계 기능이 부족
  - `JPA 2.0(JSR 317) 2009년`: 대부분의 ORM 기능 포함, JPA Criteria 추가
  - `JPA 2.1(JSR 338) 2013년`: 스토어드 프로시저 접근, 컨버터, 엔티티 그래프 기능 추가

### 왜 JPA를 사용해야 하는가?
- `생산성`
  - JDBC API 같은 반복적인 일을 JPA가 처리해줌
  - JPA는 `CREATE TABLE`같은 DDL문 역시 자동 생성 

- `유지보수`
  - SQL을 직접 다루면 수정해야할 부분이 너무 많음
  - JPA가 SQL과 JDbC API 코드를 대신 처리해줌
  - 패러다임 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점들을 활용하여 유연하고 유지보수하기 좋은 도메인 모델 편리하게 설계

- `성능`
  - JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공

- `데이터 접근 추상화와 벤더 독립성`
  - 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공하여 특정 데이터베이스 기술에 종속되지 않도록 함

- `표준`
  - JPA는 자바 진영의 ORM 표준 기술