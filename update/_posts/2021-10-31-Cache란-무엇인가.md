---
layout: post
title: Cache란 무엇인가
category: [computer-science, wooahan-techcourse]
tags: [computer-science, wooahan-techcourse]
image: /assets/img/blog/cache-main.png
accent_image: 
  background: url('/assets/img/blog/jj-ying.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  우아한 테크코스 [10분 테코톡] 큰곰의 Cache
invert_sidebar: true
---

# Cache란 무엇인가

Cache에 대해 알아보자

* toc
{:toc}

## 사전 지식
1. 메모리 계층 구조
- 데이터 저장 공간 ➜ 속도와 용량은 반비례
- 속도가 빠를수록 용량이 작음
- 용량이 클수록 속도는 느림
- 속도와 용량 두마리 토끼를 다 잡기에는 비용이 많이듦

> 속도와 용량에 따라 특성에 맞게 역할을 나눠 사용

### 메모리 계층구조
![메모리 계층 구조](/assets/img/blog/wooahan-cache-1.png){:.border.lead width="480" height="480" loading="lazy"}

2. 파레토의 법칙 (일명 2대8의 법칙)
- 이탈리아 경제학자 빌프레도 파레토가 발견
- 원인 중 상위 20%가 전체 결과 80%를 좌우
  - ex) 잘 팔리는 제품 20%가 매출의 80%를 차지, 많이 쓰이는 단어 20%가 언어 사용 빈도의 80% 차지

> 자주 쓰는 20%의 일을 가능한 몰아 넣으면 80%의 일을 효율적으로 처리할 수 있음

3. 데이터 지역성의 원리
- 자주 쓰이는 데이터는 시간적 혹은 공간적으로 한 곳에 몰려있을 가능성이 높음
- **시간 지역성(Temporla Locality)**
  - ex) `for(int i = 0; i < N; i++)`에서 i는 for문이 끝날 때까지 사용됨
- **공간 지역성(Spatial Locality)**
  - ex) for문에서 배열에 접근할 때 해당 배열이 위치한 메모리 주소 공간의 내용은 for문이 끝날 떄까지 사용
- **순차 지역성(Sequential Locality)**
  - ex) for문에서 배열에 접근할 때 arr[0], arr[1]... 다음에 arr[2]에 접근할 확률이 높음

## 캐시의 작동 방식
- 원본 데이터(System-of-Record)와는 별개로 자주 쓰이는 데이터(Hot Data)들을 복사해둘 캐시공간 마련
  - 캐시 공간은 시간 복잡도 `O(1)`등 낮은 시간 복잡도로 접근 가능 ex) Java-Hash
- 데이터 요청이 들어오면 원본 데이터가 담긴 곳에 접근하기 전에 캐시 내부부터 탐색
- 캐시에 원하는 데이터가 없거나(Cache Miss) 너무 오래되어 최신성을 잃었으면(Expiration) 그 때 원본 데이터 공간에 접근하여 데이터를 가져오고 캐시에 해당 데이터를 복사 혹은 갱신
- 캐시에 원하는 데이터가 있으면 바로 데이터를 꺼내옴(Cache Hit)
- 캐시 공간은 작으므로, 공간이 부족하면 안쓰는 데이터부터 삭제 (Eviction) ex) LRU(Least Recently Used)

## CPU의 캐시 메모리
- 현재 CPU는 1초에 최고 수십억번 작동 가능
- 아무리 빠른 주기억장치도 CPU를 따라가기 어려움 ➜ SRAM을 CPU에 넣어 캐시 메모리로 사용

## 데이터베이스
- 데이터베이스는 쓰기보다 읽기가 많으므로 자주 요청받는 쿼리의 결과를 캐싱
- 데이터베이스 자체에서 별도의 캐시 운영 ➜ JPA의 영속성 컨텍스트 역시 캐시의 일종

## CDN(Content Delivery Network)
- 세계 각지에 캐시 서버를 두어 전송속도를 높이고 부하를 분산하는 시스템

## 웹 캐시
- 브라우저 캐시: HTML, JS, CSS 등을 하드디스크나 메모리에 캐싱
- 응답 캐시: 웹 서버의 경우 매번 내용이 같은 경우 서버에서 생성한 HTML을 캐싱
- 프록시 캐시: 웹 서버 앞단의 프록시 서버에서 캐싱

## 브라우저 캐시
- 웹 서버에서 클라이언트에 보내는 HTTP 헤더에 캐시 지시자 삽입 ➜ Client Web Browser에서는 명시된 캐시 정책에 따라 캐싱
- 캐시 유효 기간(max-age)이 지나도 캐시된 데이터가 바뀌지 않는 경우를 확인하기 위해 ETag라는 유효성 검사 토큰 사용
- 캐시 유효 시간을 길게 잡으면서 정적 파일 업데이트를 빠르게 하기 위해 파일 이름 뒤에 별도의 토큰이나 버전 번호 추가
- 캐시 정책은 웹 페이지 상황에 따라 다르게 적용

## Redis
- 메모리 기반 오픈소스 NoSQL DBMS의 일종
- __Remote Dictionary Server__ : Java의 HashMap<Key, Value>
- 서버 재부팅 시 데이터가 사라지지 않게끔 데이터를 하드디스크에 기록 가능
- DBMS의 일종이므로 명시적으로 삭제하지 않는 한 메모리에서 데이터를 삭제하지 않음
- 자체적으로 여러 자료형 지원

## EHCache
- Java의 표준 캐싱 API 명세서인 JSR-107을 따르는 오픈소스 캐시 구현체
- Spring 프레임워크나 Hibernate ORM등에서 바로 사용 가능
- Java에서 가장 널리 사용
- 캐시 저장 공간을 속도에 따라 여러 등급으로 나누어 메모리 계층 구조 적용 가능
- 메모리 캐시 내용을 하드디스크에 기록 가능
- 대규모 서비스에서 캐시 서버 여럿을 클러스터로 묶을 수 있는 기능 제공