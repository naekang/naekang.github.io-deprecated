---
layout: post
title: 알고리즘 - 기본 자료형
category: [computer-science, algorithm]
tags: [computer-science, algorithm]
image: /assets/img/blog/algorithm-main.png
accent_image: 
  background: url('/assets/img/blog/jj-ying.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  [262가지 문제로 정복하는 코딩 인터뷰 in Java] 4장 기본 자료형
invert_sidebar: true
---

# 기본 자료형

> 데이터를 어떻게 표현하느냐가 프로그래밍의 핵심이다.

* toc
{:toc}

## 기본 자료형 부트캠프
- 정수에서 1로 세팅된 비트의 개수 찾는 프로그램
- 최하위 비트부터 시작하여 한번에 한 비트씩 테스트
~~~java
public static short countBits(int x) {
    short numBits = 0;
    while (x != 0) {
        numBits += (x & 1);
        x >>>= 1;
    }
    return numBits;
}
~~~
- 시간 복잡도는 `O(n)`

### 자바 비트(Shift) 연산자

| 연산식 | 설명 |
|:-------------|:------------------|
| `x << y` | 정수 x의 각 비트를 y만큼 왼쪽으로 이동 (빈자리는 0으로 채움) |
| `x >> y` | 정수 x의 각 비트를 y만큼 오른쪽으로 이동 (빈자리는 정수 a의 최상위 부호비트와 같은 값으로 채위짐) |
| `x >>> y` | 정수 x의 각 비트를 y만큼 오른쪽으로 이동 (빈자리는 0으로 채워짐) |

~~~
2 << 3
    00000000 00000000 00000000 00000010 -> 2
 00000000000 00000000 00000000 00010??? -> 16

-16 >> 3
11111111 11111111 11111111 11110000 -> -16
11111111 11111111 11111111 11111110 000 -> -2

-16 >>> 3
11111111 11111111 11111111 11110000 -> -16
00011111 11111111 11111111 11111110 000 -> 536870910
~~~

### 자바 비트 논리 연산자

| 연산식 | 논리 | 설명|
|:-------------|:------------------|
| `&` | AND | 두 비트 모두 1일 경우에만 결과가 1 |
| `|` | OR | 두 비트 중 하나만 1일 경우에만 결과가 1 |
| `^` | XOR | 두 비트 중 하나는 1이고 다른 하나가 0일 경우에만 결과가 1 |
| `~` | NOT | 비트 반전(보수) |

### 기본 자료형 문제를 풀기 전 알아야 하는 내용
- **비트 연산**, 특히 XOR
- 하드웨어랑 무관하게 **마스크**의 사용법
- **1로 세팅된 하위 비트의 값을 최적의 방법으로 지울 수 있어야 함**
- **부호**의 여부와 부호가 있을 경우 **시프트 연산**
- 입력이 작은 경우 **연산 결과를 캐싱**
- **교환법칙과 결합법칙**에 대해 잘 알고 있어야 **병렬** 연산 수행이나 **연산 순서**를 바꿀 수 있음

## 기본 자료형 이해하기
- 비트 연산 잘 다루기
- `Integer.MIN_VALUE`, `FLOAT.MAX_VALUE` 등과 같은 숫자 타입의 최댓값과 최솟값 사용법
  - 모든 경우에 Math 클래스를 사용할 수 있는 것이 아니기 때문에 직접 대소 비교를 하며 max, min을 찾아야 하는 경우
  - max, min의 초기값을 0 또는 대소비교에 영향을 주지 않는 숫자를 택하여 초기화
- 박스 타입의 인스턴스 만드는 방법
  - 문자열을 숫자로 변환하는 방법 `Integer.parseInt`
- 값을 비교할 때 `Double.compare(x, 1.23) == 0`과 같이 박스 타입의 정적 메서드 사용
  - 부동 소수점의 양수 무한대, 음수 무한대, NaN에 대해 보다 탄력적으로 동작
- Math의 핵심 메서드에는 `abs`, `ceil`, `floor`, `min`, `max`, `pow` 등이 존재
- 자동 박싱의 한계
  - `AutoBoxing`이란 자바 컴파일러가 primitive data type을 그에 상응하는 wrapper class로 자동 변환 시켜주는 것
  - `Unboxing`은 자바 컴파일러가 wrapper class를 primitive data type으로 자동 변환 시켜주는 것
  - 기본 타입과 박싱된 타입의 차이
    - 기본 타입은 값만 가지고 있지만 박싱된 타입은 값 + 식별성이라는 속성을 가짐 ➜ 박싱된 타입의 두 인스턴스는 값이 같아도 다르다고 식별될 수 있음
    - 기본 타입의 값은 NULL을 허용하지만 박싱된 타입은 허용하지 않음
    - 기본 타입이 박싱된 타입보다 시간과 메모리 사용면에서 효율적
- 정수, 문자, 문자열간의 변환 방법
  - 정수 ➜ 문자열: `String.valueOf(number)`, `"" + number`, `Integer.toString(number)`
  - 문자열 ➜ 정수: `Integer.parseInt(String str)`, `Integer.valueOf(str).intValue()`
- Random의 핵심 메서드 `nextInt()`, `nextDouble()`등이 있음

## 문제4.1 패리티 계산하기
- 2진수의 패리티(parity)는 1로 세팅된 비트의 개수가 홀수면 1, 짝수면 0
- 주로 데이터를 저장하거나 네트워크 통신 시 오류 확인 용도로 사용
- `lookup table` 이용

### 무식한 방법
- 1로 세팅된 모든 비트의 개수를 세기
- 1이 짝수 개인지 홀수 개인지를 알면 되므로 2로 나눈 나머지 값만 기억
~~~java
public static short parity(long x) {
    short result = 0;
    while (x != 0) {
        result ^= (x & 1);
        x >>>= 1;
    }
    return result;
}
~~~

### 좀 더 나은 방법 - 1
- 하위 비트를 한번에 지워서 최선의 경우가 평균적인 경우의 성능을 향상시키는 방법
- k가 1로 세팅된 비트의 개수라고 하면 시간 복잡도는 `O(k)`
~~~java
public static short parity(long x) {
    short result = 0;
    while (x != 0) {
        result ^= 1;
        x &= (x - 1); // 1로 세팅된 비트 중 가장 낮은 비트를 지우는 것
    }
    return result;
}
~~~

### 좀 더 나은 방법 - 2: 캐시 이용
- 어떤 그룹의 패리티를 계산할 때, 결합 법칙이 성립함
- 64비트를 16비트 4개의 그룹으로 나누고 계산
  - 16비트는 65356으로 배열에 저장이 가능하기 때문에 선택