---
layout: post
title: Chapter3 연산자_1
comments: true
category: [computer-science, java-basic]
tags: [computer-science, java-basic]
image: /assets/img/blog/java-main.jpeg
accent_image: 
  background: url('/assets/img/blog/jj-ying.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  자바의 정석
invert_sidebar: true
---

# 자바의 정석

자바의 정석 Chapter3
- 얼마전 비트마스킹 문제를 풀던 중 비트연산자에 대한 이해가 확실히 부족한 느낌이 들었다. 비트연산자 뿐아니라 연산자 자체에 대한 더 깊이있는 

* toc
{:toc}

## 연산자(Operator)
- '연산자'란 연산을 수행하는 기호

### 연산자와 피연산자
- 연산자: 연산을 수행하는 기호(+, -, *, / 등), 연산을 수행하고 나면 항상 결과값을 반환
- 피연산자: 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
- 'x + 3'일 경우 '+'는 덧셈 연산자, 'x'와 '3'은 피연산자

### 식과 대입연산자
- 식: 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것
- 식의 평가(evaluation): 식을 계산하여 결과를 얻는 것
- 식이 평가되어 나온 결과를 저장하기 위해 대입연산자(`=`)를 사용하여 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야 함

### 연산자의 종류

|종류|연산자|설명|
|:---:|:---:|:---:|
|산술 연산자|`+ - * / % << >>`|사칙 연산과 나머지 연산(%)|
|비교 연산자|`> < >= <= == !=`|크고 작음과 같고 다름을 비교|
|논리 연산자|`&& || ! & | ^ ~`|'그리고(AND)'와 '또는(OR)'으로 조건을 연결|
|대입 연산자|`=`|우변의 값을 좌변에 저장|
|기 타|`(type) ?: instanceof`|형변환 연산자, 삼항 연산자, instanceof연산자|

- 피연산자의 개수에 의한 분류
  - 피연산자의 개수가 하나면 '단항 연산자'
  - 피연산자의 개수가 두개면 '이항 연산자'
  - 피연산자의 개수가 세개면 '삼항 연산자'

### 연산자의 우선순위와 결합규칙

|식|설명|
|:---:|:---|
|`-x + 3`|단항 연산자가 이항 연산자에 비해 우선순위가 높기때문에 x의 부호를 바꾼 후 덧셈 수행|
|`x + 3 + y`|곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높음|
|`-x + 3 > y - 2`|비교 연산자보다 산술 연산자가 먼저 수행됨|
|`x > 3 && x < 5`|논리 연산자보다 비교 연산자가 먼저 수행됨|
|`result = x + y * 3;`|대입 연산자는 연산자 중 가장 우선순위가 낮음|

|식|설명|
|:---:|:---|
|`x << 2 + 1`|쉬프트 연산자는 덧셈 연산자보다 우선순위가 낮음, `x << (2 + 1)`과 같은 결과|
|`data & 0xFF == 0`|비트 연산자는 비교 연산자보다 우선순위가 낮음, `data & (0xFF == 0)`와 같은 결과|
|`x < -1 || x > 3 && x < 5`|논리 연산자 중 AND를 의미하는 `&, &&`가 OR을 의미하는 `|, ||`보다 우선순위가 높음, `x < - 1 || (x > 3 && x < 5)`와 같은 결과|

- 연산자의 결합규칙
  - 같은 우선순위의 연산자들이 여러 개 있는 경우, 나름대로 연산을 수행하는 규칙
  > 산술 > 비교 > 논리 > 대입. 대입은 가장 마지막에 수행
  >
  > 단항(1) > 이항(2) > 삼항(3)
  >
  > 단항 연산자와 대입 연사자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽

### 산술 변환(Usual Arithmetic Conversion)
- 이항 연산자는 두 피연산자의 타입이 일치해야 연산 가능
- 두 피연산자의 타입 같게 일치(보다 큰 타입으로 일치)
  ```java
  long + int -> long + long -> long
  float + int -> float + float -> float
  double + float -> double + double -> double
  ```
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환됨
  ```java
  byte + short -> int + int -> int
  char + short -> int + int -> int
  ```
- 일반 산술 변환
  - 연산 수행 직전에 발생하는 피연산자의 자동 형변환

## 단항 연산자

### 증감 연산자 ++, --
- 증가 연산자(++): 피연산자의 값을 1 증가시킴
  - 전위형: 값이 참조되기 전에 증가, `++i`
    ```java
    // j = ++i; 일 경우
    ++i; // 증가 후에
    j = i; // 참조하여 대입
    ```
  - 후위형: 값이 참조된 후에 증가, `i++`
    ```java
    // j = i++;
    j = i; // 참조하여 대입 후에
    i++; // 증가
    ```
- 감소 연산자(--): 피연산자의 값을 1 감소시킴
- 식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야함

### 부호 연산자 +, -
- 부호연산자 `-`는 피연산자의 부호를 반대로 변경한 결과를 반환
- boolean형과 char형을 제외한 기본형에만 사용가능

## 산술 연산자
- 사칙연산자(+, -, *, /)와 나머지 연산자(%) 존재

### 사칙연산자 +, -, *, /
- 곱셉(*), 나눗셈(/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-) 연산자보다 우선순위가 높음
- 피연산자가 정수형일 경우, 나누는 수로 0을 사용하면 에러 발생
- 부동소수점 값인 0.0f, 0.0d로 나눌 경우 결과는 Infinity(무한대)
- 크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환(casting)되지만, 반대의 경우 명시적으로 형변환 연산자를 사용해야 함
- 값손실을 막기 위해 충분히 큰 자료형을 사용해야 함

### 나머지 연산자 %
- 피연산자로 정수만 허용
- 양수, 음수 둘 다 가능하지만 부호는 무시되고 결과 반환

## 비교 연산자
- 두 피연산자 비교하는데 사용
- 주로 조건문과 반복문의 조건식으로 사용되며 결과는 `true` or `false`

### 대소비교 연산자 >, <, >=, <=
- boolean을 제외한 기본형 모두에 사용가능
- 참조형은 사용 불가능

|비교연산자|연산결과|
|:---:|:---|
|`>`|좌변 값이 크면, true 아니면 false|
|`<`|좌변 값이 작으면, true 아니면 false|
|`>=`|좌변 값이 크거나 같으면, true 아니면 false|
|`<=`|좌변 값이 작거나 같으면, true 아니면 false|

### 등가비교 연산자 ==, !=

|비교연산자|연산결과|
|:---:|:---|
|`==`|두 값이 같으면, true 아니면 false|
|`!=`|두 값이 다르면, true 아니면 false|

- 정수형과 달리 실수형은 근사값으로 저장
  - `10.0 == 10.0f`: true
  - `0.1 == 0.1f`: false
  ```java
  float f = 0.1f; // f에 0.10000000149011612로 저장
  double d = 0.1; // d에 0.10000000000000001로 저장
  ```

- 문자열의 비교
  - `equlas()` 메서드를 사용하여 비교
  - 객체가 달라도 내용이 같으면 true 반환