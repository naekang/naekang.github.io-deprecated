---
layout: post
title: Chapter1 JPA tlwkr
category: [computer-science, jpa]
tags: [computer-science, jpa]
image: /assets/img/blog/jpa-main.png
accent_image: 
  background: url('/assets/img/blog/jj-ying.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  자바 ORM 표준 JPA 프로그래밍
invert_sidebar: true
---

# 자바 ORM 표준 JPA 프로그래밍

- ORM(Object-Relational Mapping)을 사용한 기술인 JPA를 통해 객체 중심 개발이 가능해지고 생산성과 유지보수가 좋아졌으며 테스트 작성 역시 편해졌다.

* toc
{:toc}

## 이클립스 설치와 프로젝트 불러오기
- 책의 경우 이클립스를 사용했으나 나는 인텔리제이를 사용할 예정이다.
- 자바 버전: openjdk 11.0.11
- gradle 사용
- h2 데이터베이스 사용
  - 드라이버 클래스: `org.h2.Driver`
  - JBDC URL: jdbc:h2:tcp://localhost/~/test
  - 사용자명: sa
  - 비밀번호: 없음
    
## 객체 매핑 시작
- h2 데이터베이스를 이용하여 테이블 생성
    ```sql
    CREATE TABLE MEMBER (
        ID VARCHAR(255) NOT NULL,
        NAME VARCHAR(255),
        AGE INTEGER NOT NULL,
        PRIMARY KEY (ID)
    )
    ```
- 회원 클래스 만들기
  ~~~java
  // Memeber.java
  @Entity
  @Table(name="MEMBER")
  public class Member {

    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME")
    private String username;

    private Integer age;

    public String getId() { return id; }

    public void setId(String id) { this.id = id; }

    public String getUsername() { return username; }

    public void setUsername(String username) { this.username = username; }

    public Integer getAge() { return age; }

    public void setAge(Integer age) { this.age = age; }
  }
  ~~~
- 회원 클래스와 회원 테이블의 비교
  
  |매핑 정보|회원 객체|회원 테이블|
  |:---:|:---:|:---:|
  |클래스와 테이블|Member|MEMBER|
  |기본 키|id|ID|
  |필드와 칼럼|username|NAME|
  |필드와 칼럼|age|AGE|

- 회원 클래스에 사용된 어노테이션 분석하기
  - `@Entity`
    - 테이블과 매핑한다고 JPA에 알려줌
    - '엔티티 클래스'라고 부름
    - 기본 생성자 필수 - 파라미터가 없는 `public` 또는 `protected` 생성자 필요
    - `@Entity(name = "Member"`를 통해 JPA에서 사용할 엔티티 이름 지정 (default: 클래스 이름)
  - `@Table`
    - 엔티티 클래스에 매핑할 테이블 지정
    - `@Table(name = "MEMBER")`를 통해 매핑할 테이블 이름 지정 (default: 엔티티 이름)
  - `@Id`
    - 엔티티 클래스의 필드를 테이블의 기본 키에 매핑
    - @Id가 사용된 필드를 식별자 필드라고 함
    - `@GeneratedValue(stategy = Generation.Type.000)`를 통해 자동 생성 가능
      - `IDENTITY`: 기본 키 생성을 데이터베이스에 위임(=AUTO_INCREMENT)
      - `SEQUENCE`: 데이터베이스 시퀀스를 사용하여 기본 키 할당
      - `TABLE`: 키 생성 테이블 사용, 키 생성 전용 테이블을 만들고 이름과 값으로 사용할 컬럼을 만들어 시퀀스를 흉내냄
      - `AUTO`: 선택한 데이터베이스 방언에 따라 방식 자동선택 - default 값
  - `@Column`
    - 객체 필드를 컬럼에 매핑
    - `@Column(name = "NAME")`를 통해 엔티티 클래스의 **username**을 테이블의 **NAME**컬럼에 매핑
    - `@Column(nullable = false)`를 통해 null값의 허용 여부를 결정할 수 있으나 false로 사용하는 것이 안전 
  - `매핑 정보가 없는 필드`
    - 매핑 어노테이션을 생략하면 필드명을 사용해 컬럼명으로 매핑
    - 대소문자를 구분하는 데이터베이스의 경우 `@Column(name = "AGE")`처럼 명시적으로 매핑해야 함

### persistence.xml 설정
- `META-INF/persistence.xml` 경로에 있는 경우 별도의 설정 없이 JPA가 인식 가능

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- XML 네임스페이스와 버전 지정 -->
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1">

    <!-- 데이터베이스당 하나의 영속성 유닛 등록 -->
    <persistence-unit name="jpa-basic-example">

        <properties>

            <!-- 필수 속성 -->
            <!-- JDBC 드라이버 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <!-- 데이터베이스 접속 아이디 -->
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <!-- 데이터베이스 접속 비밀번호 -->
            <property name="javax.persistence.jdbc.password" value=""/>
            <!-- 데이터베이스 접속 URL -->
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <!-- 데이터베이스 방언(dialect) 설정 -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" />

            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />
            <property name="hibernate.use_sql_comments" value="true" />
            <property name="hibernate.id.new_generator_mappings" value="true" />

            <!--<property name="hibernate.hbm2ddl.auto" value="create" />-->
        </properties>
    </persistence-unit>
</persistence>
~~~

- 데이터베이스 방언
  - 특정 데이터베이스만의 고유한 기능
  - 데이터베이스가 제공하는 SQL 문법과 함수가 조금씩 다름
    - **데이터 타입**: 가변 문자 타입으로 MySQL은 `VARCHAR`, 오라클은 `VARCHAR2` 사용
    - **다른 함수명**: 문자열을 자르는 함수로 SQL 표준은 `SUBSTRING()`, 오라클은 `SUBSTR()`
    - **페이징 처리**: MySQL은 `LIMIT`, 오라클은 `ROWNUM`
  - ![데이터베이스 방언](/assets/img/blog/jpa-basic-4-1.png){:.border.lead width="480" height="480" loading="lazy"}
  ```
  H2: org.hibernate.dialect.H2Dialect
  오라클 10g: org.hibernate.dialect.Oracle10gDialect
  MySQL: org.hiberante.dialect.MySQL5InnoDBDialect
  ```

### 애플리케이션 개발
~~~java
// JpaMain.java
public static void main(String[] args) {

        // 엔티티 매니저 팩토리 생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpa-basic-example");
        // 엔티티 매니저 생성
        EntityManager em = emf.createEntityManager();
        // 트랜잭션 획득
        EntityTransaction tx = em.getTransaction();

        try {

            tx.begin(); // 트랜잭션 시작
            logic(em); // 비즈니스 로직 실행
            tx.commit(); // 트랜잭션 커밋

        } catch (Exception e) {
            tx.rollback(); // 트랜잭션 롤백
        } finally {
            em.close(); // 엔티티 매니저 종료
        }
        emf.close(); // 엔티티 매니저 팩토리 종료
    }
~~~
- 엔티티 매니저 생성
![엔티티 매니저 생성](/assets/img/blog/jpa-basic-4-2.png){:.border.lead width="480" height="480" loading="lazy"}
  - 엔티티 매니저 팩토리 생성
    - `EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpa-basic-example");` : persistence.xml 설정 정보 사용하여 엔티티 매니저 팩토리 생성
    - `META-INF/persistence.xml`에서 이름이 `jpa-basic-example`인 영속성 유닛을 찾아 엔티티 매니저 팩토리 생성
    - JPA 동작을 위한 객체 생성 -> JPA에 따라 데이터베이스 커넥션 풀 생성 : 비용이 큼
    - 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야함
  - 엔티티 매니저 생성
    - `EntityManager em = emf.createEntityManager();`
    - 엔티티 매니저를 사용하여 엔티티를 데이터베이스에 등록/수정/삭제/조회 가능
    - 애플리케이션 개발자는 엔티티 매니저를 가상의 데이터베이스로 생각
    - 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안됨
  - 종료
    - `em.close()` & `emf.close()`

- 트랜잭션 관리
  - JPA 사용을 위해서는 항상 트랜잭션 안에서 데이터를 변경해야 함
  - 트랜잭션을 시작하려면 엔티티 매니저에서 트랜잭션 API를 받아와야 함

- 비즈니스 로직
  - 회원 엔티티 하나 생성 후 등록, 수정, 삭제, 조회
  ~~~java
  public static void logic(EntityManager em) {
    String id = "id1";
    Member member = new Member();
    member.setId(id);
    member.setUsername("하울");
    member.setAge(25);

    // 등록
    em.persist(member);

    // 수정
    member.setAge(2);

    // 한 건 조회
    Member findMember = em.find(Member.class, id);
    System.out.println("findMember=" + findMember.getUsername() + ", age=" + findMember.getAge());

    // 목록 조회
    List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
    System.out.println("members.size=" + members.size());

    // 삭제
    em.remove(member);
  }
  ~~~
  ```
  findMember=하울, age=2
  members.size=1
  ```
  - JPA는 회원 엔티티의 매핑 정보(어노테이션)을 분석해서 다음 SQL 생성
    `INSERT INTO MEMBER (ID, NAME, AGE) VALUES ('id1', '하울', 25)`
  - JPA는 어떤 엔티티가 변경되었는지 추적하는 기능이 있음

### JPQL
- JPA는 엔티티 객체를 중심으로 개발하므로 검색을 할 떄에도 엔티티 객체를 대상으로 검색해야 함
- JPQL: **엔티티** 객체를 대상으로 쿼리 (즉, 클래스와 필드 대상), 데이터베이스 테이블을 전혀 알지 못함
- SQL: **데이터베이스** 테이블을 대상으로 쿼리